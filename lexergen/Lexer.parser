[cpp]#include <soulng/code/Statement.hpp>
[cpp]#include <soulng/code/Declarator.hpp>
[hpp]#include <soulng/lexergen/Model.hpp>

namespace soulng.lexergen
{
    grammar LexerGrammar
    {
        using stdlib.identifier;
        using stdlib.string;
        using stdlib.int;
        using stdlib.spaces_and_comments;
        using soulng.code.Statement.CompoundStatement;
        using soulng.code.Declarator.TypeId;
        skip spaces_and_comments;

        LexerFile : LexerFile*
            ::= empty{ value = new LexerFile(); } (Declaration{ value->Add(Declaration); })*
            ;

        Declaration : Declaration*
            ::= ClassMap{ value = ClassMap; }
            |   Prefix{ value = Prefix; }
            |   Include{ value = Include; }
            |   Tokens{ value = Tokens; }
            |   Keywords{ value = Keywords; }
            |   Expressions{ value = Expressions; }
            |   Lexer{ value = Lexer; }
            ;

        ClassMap : ClassMap*
            ::= keyword("classmap") Identifier!{ value = new ClassMap(Identifier); } ';'!
            ;

        Prefix : Prefix*
            ::= keyword("prefix") string:prefix!{ value = new Prefix(prefix); } ';'!
            ;

        Include : Include*
            ::= ("#include" token('<' [^>]* '>')){ value = new Include(std::u32string(matchBegin, matchEnd)); }
            ;

        Tokens : Tokens*
            ::= keyword("tokens") Identifier!{ value = new Tokens(Identifier); } '{'! (Token{ value->Add(Token); } % ',')? '}'!
            ;

        Token : Token
            ::= ('(' Identifier:id! ','! string:info! ')'!){ value = Token(id, ToUtf8(info)); }
            ;

        Keywords : Keywords*
            ::= keyword("keywords") Identifier!{ value = new Keywords(Identifier); } '{'! (Keyword{ value->Add(Keyword); } % ',')? '}'!
            ;

        Keyword : Keyword*
            ::= ('(' string:kw! ','! Identifier:tkn! ')'!){ value = new Keyword(kw, tkn); }
            ;

        Expressions(var int index) : Expressions*
            ::= keyword("expressions"){ value = new Expressions(); } '{'! (Expression(index){ value->Add(Expression); index = index + 1; })* '}'!
            ;

        Expression(int index) : Expression*
            ::= (Identifier:id '='! Expr:val! ';'!){ value = new Expression(index, id, val); }
            ;

        Expr : std::u32string
            ::= token('"' (('\\' '"'){ value.append(1, '"'); } | [^"]{ value.append(1, *matchBegin); })* '"')
            ;

        Variable : Variable*
            ::= (TypeId:type Identifier:name! ';'){ value = new Variable(type, name); }
            ;

        Lexer : Lexer*
            ::= keyword("lexer") Api Identifier!{ value = new Lexer(Api, Identifier); } '{'! (LexerClause(value))* '}'!
            ;

        LexerClause(Lexer* lexer)
            ::= (Expr:expr (Action:action)? CompoundStatement:stmt!){ lexer->AddStatement(new LexerStatement(expr, stmt, action)); }
            |   Variables(lexer)
            |   Actions(lexer)
            ;

        Variables(Lexer* lexer)
            ::= keyword("variables") '{'! (Variable:variable{ lexer->AddVariable(variable); })* '}'!
            ;

        Identifier : std::u32string
            ::= (identifier - LexerKeyword){ value = identifier; }
            ;

        Api : std::u32string
            ::= (keyword("api") '(' identifier:id ')'){ value = id; } | empty
            ;

        LexerKeyword
            ::= keyword_list(identifier, ["tokens", "keywords", "expressions", "lexer", "actions", "api"])
            ;

        Actions(Lexer* lexer)
            ::= keyword("actions") '{'! ((Action:action '='! CompoundStatement:stmt!){ lexer->AddAction(new soulng::lexergen::Action(action, stmt)); })* '}'!
            ;

        Action : int
            ::= token('$' '(' int:i{ value = i; } ')')
            ;
    }
} // namespace soulng::lexergen
