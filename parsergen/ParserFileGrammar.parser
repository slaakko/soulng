[hpp]#include <soulng/parsergen/ParserFile.hpp>
[cpp]#include <soulng/code/Declarator.hpp>
[cpp]#include <soulng/code/Expression.hpp>
[cpp]#include <soulng/code/Statement.hpp>
[cpp]#include <soulng/code/Identifier.hpp>

namespace soulng.parsergen
{
    grammar ParserFileGrammar
    {
        using stdlib.identifier;
        using stdlib.string;
        using stdlib.spaces_and_comments;
        using soulng.code.Declarator.TypeId;
        using soulng.code.Declarator.Declarator;
        using soulng.code.Expression.ExpressionList;
        using soulng.code.Statement.CompoundStatement;
        using soulng.code.Identifier.QualifiedId;
        skip spaces_and_comments;

        ParserFile : ParserFile*
            ::= empty{ value = new ParserFile(fileName); } Declaration(value):declaration*
            ;

        Declaration(ParserFile* parserFile)
            ::= IncludeDeclaration:include{ parserFile->AddInclude(include); }
            |   UsingNamespaceDeclaration:usingNs{ parserFile->AddUsingNamespace(usingNs); }
            |   GrammarDeclaration:grmr{ parserFile->AddGrammar(grmr); }
            ;

        IncludeDeclaration(var std::u32string include) : Include*
            ::= (IncludePrefix:prefix? ("#include" token('<' [^>]* '>')){ include = std::u32string(matchBegin, matchEnd); }){ value = new Include(prefix, include); }
            ;

        IncludePrefix : bool
            ::= "[cpp]"{ value = false; }
            |   "[hpp]"{ value = true; }
            ;

        UsingNamespaceDeclaration : std::u32string
            ::= (keyword("using") keyword("namespace") QualifiedId:qid ';'){ value = std::u32string(matchBegin, matchEnd); }
            ;

        GrammarDeclaration : soulng::parsergen::GrammarParser*
            ::= keyword("parser") Identifier:grammarName{ value = new soulng::parsergen::GrammarParser(grammarName); } '{'! GrammarStatement(value)* '}'!
            ;

        GrammarStatement(soulng::parsergen::GrammarParser* grammar)
            ::= MainStatement(grammar)
            |   UsingStatement(grammar)
            |   LexerStatement(grammar)
            |   RuleInfoStatement(grammar)
            |   RuleStatement(grammar)
            ;

        MainStatement(soulng::parsergen::GrammarParser* grammar)
            ::= (keyword("main") ';'!){ grammar->SetMain(); }
            ;

        UsingStatement(soulng::parsergen::GrammarParser* grammar)
            ::= (keyword("using") UsingQualifiedId:id ';'!){ grammar->AddUsing(id); }
            ;

        LexerStatement(soulng::parsergen::GrammarParser* grammar)
            ::= (keyword("lexer") Identifier:id ';'!){ grammar->SetLexer(id); }
            ;

        RuleInfoStatement(soulng::parsergen::GrammarParser* grammar)
            ::= keyword("ruleinfo") '{' (RuleInfo(grammar) % ',')? '}'
            ;

        RuleInfo(soulng::parsergen::GrammarParser* grammar)
            ::= ('(' Identifier:ruleName! ','! string:ruleInfo! ')'!){ grammar->AddRuleInfo(ruleName, ruleInfo); }
            ;

        RuleStatement(soulng::parsergen::GrammarParser* grammar)
            ::= (Identifier:ruleName ParameterList:params? ReturnType:returnType? "::="! RuleBody:definition! ';'!)
            {
                soulng::parsergen::RuleParser* rule = new soulng::parsergen::RuleParser(ruleName, definition);
                rule->SetParameters(params);
                rule->SetReturnType(returnType);
                grammar->AddRule(rule);
            }
            ;

        RuleBody : soulng::parsergen::Parser*
            ::= Alternative:alt{ value = alt; }
            ;

        Alternative : soulng::parsergen::Parser*
            ::= Sequence:left{ value = left; } ('|' Sequence:right!{ value = new soulng::parsergen::AlternativeParser(value, right); })*
            ;

        Sequence : soulng::parsergen::Parser*
            ::= Difference:left{ value = left; } (Difference:right{ value = new soulng::parsergen::SequenceParser(value, right); })*
            ;

        Difference : soulng::parsergen::Parser*
            ::= List:left{ value = left; } ('-' List:right!{ value = new soulng::parsergen::DifferenceParser(value, right); })*
            ;

        List : soulng::parsergen::Parser*
            ::= Postfix:left{ value = left; } ('%' Postfix:right!{ value = new soulng::parsergen::ListParser(value, right); })?
            ;

        Postfix : soulng::parsergen::Parser*
            ::= Primary:primary{ value = primary; }
            (   '*'{ value = new soulng::parsergen::KleeneParser(value); }
            |   '+'{ value = new soulng::parsergen::PositiveParser(value); }
            |   '?'{ value = new soulng::parsergen::OptionalParser(value); }
            )?
            ;

        Primary : soulng::parsergen::Parser*
            ::=
            (   RuleCall{ value = RuleCall; }
            |   Primitive{ value = Primitive; }
            |   Grouping{ value = Grouping; }
            )
            (   Expectation(value){ value = Expectation; }  )?
            (   Action(value){ value = Action; }    )?
            ;

        RuleCall : soulng::parsergen::Parser*
            ::= ((token(Nonterminal:ntArgs '(') ExpressionList:args! ')'! | Nonterminal:nt) ':' Identifier:name!)
            {
                std::u32string ruleName;
                if (!ntArgs.empty())
                {
                    ruleName = ntArgs;
                }
                else
                {
                    ruleName = nt;
                }
                soulng::parsergen::NonterminalParser* parser = new soulng::parsergen::NonterminalParser(name, ruleName);
                if (!args.empty())
                {
                    parser->SetArguments(args);
                }
                value = parser;
            }
            ;

        Primitive : soulng::parsergen::Parser*
            ::= keyword("empty"){ value = new soulng::parsergen::EmptyParser(); }
            |   Identifier:tkn{ value = new soulng::parsergen::TokenParser(tkn); }
            ;

        Grouping : soulng::parsergen::Parser*
            ::= ('(' Alternative:alt! ')'!){ value = new soulng::parsergen::GroupingParser(alt); }
            ;

        Expectation(soulng::parsergen::Parser* parser) : soulng::parsergen::Parser*
            ::= '!'{ value = new soulng::parsergen::ExpectationParser(parser); }
            ;

        Action(soulng::parsergen::Parser* parser) : soulng::parsergen::Parser*
            ::= (CompoundStatement:successCode ('/' CompoundStatement:failureCode)?){ value = new soulng::parsergen::ActionParser(successCode, failureCode, parser); }
            ;

        Nonterminal : std::u32string
            ::= Identifier:nt{ value = nt; }
            ;

        ParameterList : std::vector<soulng::parsergen::Parameter*>
            ::= '(' (Parameter:param{ value.push_back(param); } % ',')? ')'!
            ;

        Parameter : soulng::parsergen::Parameter*
            ::= (keyword("var") TypeId:vartype Declarator:varname){ value = new soulng::parsergen::Variable(vartype, varname); }
            |   (TypeId:paramtype Declarator:paramname){ value = new soulng::parsergen::Parameter(paramtype, paramname); }
            ;

        ReturnType : soulng::codedom::TypeId*
            ::= ':' TypeId:type{ value = type; }
            ;

        Keyword
            ::= keyword_list(identifier, ["parser", "lexer", "using", "namespace", "empty", "main", "ruleinfo"])
            ;

        Identifier : std::u32string
            ::= (identifier:id - Keyword){ value = id; }
            ;

        UsingQualifiedId : std::u32string
            ::= token(Identifier:left ('.' Identifier:right)*){ value = std::u32string(matchBegin, matchEnd); }
            ;
    }
}
