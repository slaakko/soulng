// =================================
// Copyright (c) 2019 Seppo Laakko
// Distributed under the MIT license
// =================================

[hpp]#include <cmajor/parser/ParserApi.hpp>
[hpp]#include <cmajor/ast/Project.hpp>
[cpp]#include <cmajor/lexer/ContainerFileLexer.hpp>
[cpp]#include <cmajor/lexer/ContainerFileTokens.hpp>

using namespace cmajor::ast;
using namespace ContainerFileTokens;

parser api(CMAJOR_PARSER_API) ProjectFileParser
{
    uselexer ContainerFileLexer;
    main;

    ProjectFile(std::string config, cmajor::ast::BackEnd backend, var std::unique_ptr<Project> project) : cmajor::ast::Project*
        ::=
        (
            PROJECT QualifiedId:name! SEMICOLON!{ project.reset(new Project(name, lexer.FileName(), config, backend)); }
            (Declaration:declaration{ project->AddDeclaration(declaration); })*
        )
        {
            return project.release();
        }
        ;

    QualifiedId(var Span s) : std::u32string
        ::=
        (
            ID{ s = span; } (DOT ID{ s.end = span.end; })*
        )
        {
            return lexer.GetMatch(s);
        }
        ;

    Declaration : ProjectDeclaration*
        ::= ReferenceDeclaration:referenceDeclaration{ return referenceDeclaration; }
        |   SourceFileDeclaration:sourceFileDeclaration{ return sourceFileDeclaration; }
        |   TextFileDeclaration:textFileDeclaration{ return textFileDeclaration; }
        |   TargetDeclaration:targetDeclaration{ return targetDeclaration; }
        ;

    ReferenceDeclaration(var std::string filePath) : ProjectDeclaration*
        ::= REFERENCE FILEPATH!{ filePath = lexer.filePath; } SEMICOLON!{ return new cmajor::ast::ReferenceDeclaration(filePath); }
        ;

    SourceFileDeclaration(var std::string filePath) : ProjectDeclaration*
        ::= SOURCE FILEPATH!{ filePath = lexer.filePath; } SEMICOLON!{ return new cmajor::ast::SourceFileDeclaration(filePath); }
        ;

    TextFileDeclaration(var std::string filePath) : ProjectDeclaration*
        ::= TEXT FILEPATH!{ filePath = lexer.filePath; } SEMICOLON!{ return new cmajor::ast::TextFileDeclaration(filePath); }
        ;

    TargetDeclaration : ProjectDeclaration*
        ::= TARGET ASSIGN! Target:target! SEMICOLON!{ return new cmajor::ast::TargetDeclaration(target); }
        ;

    Target : cmajor::ast::Target
        ::= PROGRAM{ return cmajor::ast::Target::program; }
        |   LIBRARY{ return cmajor::ast::Target::library; }
        |   UNITTEST{ return cmajor::ast::Target::unitTest; }
        ;

    ruleinfo
    {
        (ProjectFile, "project file"), (QualifiedId, "identifier"), (Declaration, "project file declaration"),
        (ReferenceDeclaration, "reference declaration"), (SourceFileDeclaration, "source file declaration"),
        (TextFileDeclaration, "text file declaration"), (TargetDeclaration, "target declaration"),
        (Target, "target")
    }
}
