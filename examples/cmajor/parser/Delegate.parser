// =================================
// Copyright (c) 2019 Seppo Laakko
// Distributed under the MIT license
// =================================

[hpp]#include <cmajor/parser/ParserApi.hpp>
[hpp]#include <cmajor/ast/Delegate.hpp>
[hpp]#include <cmajor/parser/ParsingContext.hpp>
[cpp]#include <cmajor/parser/Specifier.hpp>
[cpp]#include <cmajor/parser/TypeExpr.hpp>
[cpp]#include <cmajor/parser/Identifier.hpp>
[cpp]#include <cmajor/parser/Parameter.hpp>
[cpp]#include <cmajor/lexer/CmajorLexer.hpp>
[cpp]#include <cmajor/lexer/CmajorTokens.hpp>

using namespace cmajor::ast;
using namespace CmajorTokens;

parser api(CMAJOR_PARSER_API) DelegateParser
{
    uselexer CmajorLexer;

    using SpecifierParser.Specifiers;
    using TypeExprParser.TypeExpr;
    using ParameterParser.ParameterList;
    using IdentifierParser.Identifier;

    Delegate(ParsingContext* ctx, var Span s, var std::unique_ptr<DelegateNode> dlg) : DelegateNode*
        ::= Specifiers:specifiers{ s = span; } DELEGATE TypeExpr(ctx):type! Identifier:id!{ dlg.reset(new DelegateNode(s, specifiers, type, id)); }
            ParameterList(ctx, dlg.get()):paramList! SEMICOLON!{ dlg->SetSpanEnd(span.end); return dlg.release(); }
        ;

    ClassDelegate(ParsingContext* ctx, var Span s, var std::unique_ptr<ClassDelegateNode> clsDlg) : ClassDelegateNode*
        ::= Specifiers:specifiers{ s = span; } CLASS DELEGATE TypeExpr(ctx):type! Identifier:id!{ clsDlg.reset(new ClassDelegateNode(s, specifiers, type, id)); }
            ParameterList(ctx, clsDlg.get()):paramList! SEMICOLON!{ clsDlg->SetSpanEnd(span.end); return clsDlg.release(); }
        ;

    ruleinfo
    {
        (Delegate, "delegate"), (ClassDelegate, "class delegate")
    }
}
