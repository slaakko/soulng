using System;
using System.Collections;

namespace soulcm.scm2html
{
    public abstract class Declaration
    {
        public Declaration(const ustring& name_) :
            name(name_)
        {
        }
        public virtual ~Declaration()
        {
        }
        public const ustring& Name() const
        {
            return name;
        }
        private ustring name;
    }
    public class ClassMap : Declaration
    {
        public ClassMap(const ustring& name_) :
            base(name_)
        {
        }
    }
    public class Usings : Declaration
    {
        public Usings() :
            base(u"usings")
        {
        }
        public const List<UniquePtr<Cm.Ast.Node>>& UsingNodes() const
        {
            return usingNodes;
        }
        public void AddMember(Cm.Ast.Node* usingNode)
        {
            usingNodes.Add(UniquePtr<Cm.Ast.Node>(usingNode));
        }
        private List<UniquePtr<Cm.Ast.Node>> usingNodes;
    }
    public class Token
    {
        public Token() :
            name(), info()
        {
        }
        public Token(const ustring& name_, const string& info_) :
            name(name_), info(info_)
        {
        }
        public ustring name;
        public string info;
    }
    public class Tokens : Declaration
    {
        public Tokens(const ustring& name_) :
            base(name_)
        {
        }
        public void Add(const Token& token)
        {
            tokens.Add(token);
        }
        private List<Token> tokens;
    }
    public class Keyword
    {
        public Keyword(const ustring& kw_, const ustring& token_) :
            kw(kw_), token(token_)
        {
        }
        public ustring kw;
        public ustring token;
    }
    public class Keywords : Declaration
    {
        public Keywords(const ustring& name_) :
            base(name_)
        {
        }
        public void Add(Keyword* keyword)
        {
            keywords.Add(UniquePtr<Keyword>(keyword));
        }
        private List<UniquePtr<Keyword>> keywords;
    }
    public class Expression
    {
        public Expression(int index_, const ustring& id_, const ustring& value_, int line_) :
            index(index_), id(id_), value(value_), line(line_)
        {
        }
        public int Index() const
        {
            return index;
        }
        public const ustring& Id() const
        {
            return id;
        }
        public const ustring& Value() const
        {
            return value;
        }
        public int Line() const
        {
            return line;
        }
        private int index;
        private ustring id;
        private ustring value;
        private int line;
    }
    public class Expressions : Declaration
    {
        public Expressions() :
            base(u"expressions")
        {
        }
        public void Add(Expression* expression)
        {
            expressions.Add(UniquePtr<Expression>(expression));
            exprMap[expression->Id()] = expression->Index();
        }
        public Expression* Get(const ustring& id) const
        {
            Map<ustring, int>.ConstIterator it = exprMap.CFind(id);
            if (it != exprMap.CEnd())
            {
                int index = it->second;
                return expressions[index].Get();
            }
            else
            {
                throw Exception("expression \'" + ToUtf8(id) + "\' not found");
            }
        }
        private List<UniquePtr<Expression>> expressions;
        private Map<ustring, int> exprMap;
    }
    public class Variable
    {
        public Variable(Cm.Ast.Node* type_, const ustring& name_) :
            type(type_), name(name_)
        {
        }
        public Cm.Ast.Node* GetType() const
        {
            return type.Get();
        }
        public const ustring& Name() const
        {
            return name;
        }
        private UniquePtr<Cm.Ast.Node> type;
        private ustring name;
    }
    public class LexerStatement
    {
        public LexerStatement(const ustring& expr_, Cm.Ast.CompoundStatementNode* stmt_, int action_, int line_) :
            index(-1), expr(expr_), stmt(stmt_), retract(true), action(action_), line(line_)
        {
        }
        public void SetIndex(int index_)
        {
            index = index_;
        }
        public int Index() const
        {
            return index;
        }
        public Cm.Ast.CompoundStatementNode* Code() const
        {
            return stmt.Get();
        }
        public bool Retract() const
        {
            return retract;
        }
        public int Action() const
        {
            return action;
        }
        public int Line() const
        {
            return line;
        }
        private int index;
        private ustring expr;
        private UniquePtr<Cm.Ast.CompoundStatementNode> stmt;
        private bool retract;
        private int action;
        private int line;
    }
    public class Action
    {
        public Action(int id_, Cm.Ast.CompoundStatementNode* stmt_) :
            id(id_), stmt(stmt_)
        {
        }
        public int Id() const
        {
            return id;
        }
        public Cm.Ast.CompoundStatementNode* Code() const
        {
            return stmt.Get();
        }
        private int id;
        private UniquePtr<Cm.Ast.CompoundStatementNode> stmt;
    }
    public class Actions : Declaration
    {
        public Actions() :
            base(u"actions")
        {
        }
        public void Add(Action* action)
        {
            actions.Add(UniquePtr<Action>(action));
            actionMap[action->Id()] = action;
        }
        public Action* Get(int id) const
        {
            Map<int, Action*>.ConstIterator it = actionMap.CFind(id);
            if (it != actionMap.CEnd())
            {
                return it->second;
            }
            else
            {
                return null;
            }
        }
        private List<UniquePtr<Action>> actions;
        private Map<int, Action*> actionMap;
    }
    public class Lexer : Declaration
    {
        public Lexer(const ustring& api_, const ustring& name_) :
            base(name_), api(api_)
        {
        }
        public void AddStatement(LexerStatement* stmt)
        {
            stmt->SetIndex(cast<int>(statements.Count()));
            statements.Add(UniquePtr<LexerStatement>(stmt));
        }
        public void AddVariable(Variable* variable)
        {
            variables.Add(UniquePtr<Variable>(variable));
        }
        public void AddAction(Action* action)
        {
            actions.Add(action);
        }
        private ustring api;
        private List<UniquePtr<LexerStatement>> statements;
        private List<UniquePtr<Variable>> variables;
        private Actions actions;
    }
    public class LexerFile
    {
        public void Add(Declaration* declaration)
        {
            declarations.Add(UniquePtr<Declaration>(declaration));
            declarationMap[declaration->Name()] = declaration;
        }
        private List<UniquePtr<Declaration>> declarations;
        private Map<ustring, Declaration*> declarationMap;
    }
}
