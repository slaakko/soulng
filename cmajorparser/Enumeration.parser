// =================================
// Copyright (c) 2019 Seppo Laakko
// Distributed under the MIT license
// =================================

[hpp]#include <cmajorast/Enumeration.hpp>
[hpp]#include <cmajorparser/ParsingContext.hpp>
[cpp]#include <cmajorparser/Specifier.hpp>
[cpp]#include <cmajorparser/Identifier.hpp>
[cpp]#include <cmajorparser/TypeExpr.hpp>
[cpp]#include <cmajorparser/Expression.hpp>
[cpp]#include <soulng/cmajorlexer/CmajorLexer.hpp>
[cpp]#include <soulng/cmajorlexer/CmajorTokens.hpp>

using namespace cmajor::ast;
using namespace CmajorTokens;

parser EnumerationParser
{
    lexer CmajorLexer;

    using SpecifierParser.Specifiers;
    using IdentifierParser.Identifier;
    using TypeExprParser.TypeExpr;
    using ExpressionParser.Expression;

    EnumType(ParsingContext* ctx, var std::unique_ptr<EnumTypeNode> enumTypeNode, var Span s, var Span beginBraceSpan, var Span endBraceSpan) : EnumTypeNode*
        ::= Specifiers:specifiers{ s = span; } ENUM Identifier:enumTypeId!{ s.end = span.end; enumTypeNode.reset(new EnumTypeNode(s, specifiers, enumTypeId)); }
            (UnderlyingType(ctx):underlyingType{ enumTypeNode->SetUnderlyingType(underlyingType); })?
            LBRACE!{ beginBraceSpan = span; } EnumConstants(ctx, enumTypeNode.get()):enumConstants RBRACE!
            {
                endBraceSpan = span;
                enumTypeNode->SetBeginBraceSpan(beginBraceSpan);
                enumTypeNode->SetEndBraceSpan(endBraceSpan);
                return enumTypeNode.release();
            }
        ;

    UnderlyingType(ParsingContext* ctx) : Node*
        ::= COLON TypeExpr(ctx):type{ return type; }
        ;

    EnumConstants(ParsingContext* ctx, cmajor::ast::EnumTypeNode* enumType)
        ::= EnumConstant(ctx, enumType):enumConstant!{ enumType->AddConstant(enumConstant); } % COMMA
        ;

    EnumConstant(ParsingContext* ctx, cmajor::ast::EnumTypeNode* enumType, var Span s) : EnumConstantNode*
        ::= Identifier:constantId!{ s = span; }
        (   ASSIGN Expression(ctx):constantValue
            {
                s.end = span.end;
                EnumConstantNode* value = new EnumConstantNode(s, constantId, constantValue);
                value->SetHasValue();
                value->SetStrValue(lexer.GetMatch(s));
                return value;
            }
        |   empty{ return new EnumConstantNode(s, constantId, MakeNextEnumConstantValue(s, enumType)); }
        )
        ;

    ruleinfo
    {
        (EnumType, "enumerated type"), (UnderlyingType, "underlying type"), (EnumConstants, "enumeration constants"), (EnumConstant, "enumeration constant")
    }
}
